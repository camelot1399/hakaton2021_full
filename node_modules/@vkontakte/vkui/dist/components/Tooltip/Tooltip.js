import _extends from "@babel/runtime/helpers/extends";
import _typeof from "@babel/runtime/helpers/typeof";
import _objectWithoutProperties from "@babel/runtime/helpers/objectWithoutProperties";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import { createScopedElement } from "../../lib/jsxRuntime";
import React, { Fragment, cloneElement, isValidElement, useState, useRef, useMemo, Children } from 'react';
import { classNames } from "../../lib/classNames";
import { getClassName } from "../../helpers/getClassName";
import ReactDOM from 'react-dom';
import { useDOM } from "../../lib/dom";
import { useIsomorphicLayoutEffect } from "../../lib/useIsomorphicLayoutEffect";
import Subhead from "../Typography/Subhead/Subhead";
import { tooltipContainerAttr } from "./TooltipContainer";
import { useExternRef } from "../../hooks/useExternRef";
import { useGlobalEventListener } from "../../hooks/useGlobalEventListener";
import { warnOnce } from "../../lib/warnOnce";
import { hasReactNode } from "../../lib/utils";

var isDOMTypeElement = function isDOMTypeElement(element) {
  return /*#__PURE__*/React.isValidElement(element) && typeof element.type === 'string';
};

var baseClassName = getClassName('Tooltip');
var warn = warnOnce('Tooltip');
var IS_DEV = process.env.NODE_ENV === 'development';

var TooltipPortal = function TooltipPortal(_ref) {
  var header = _ref.header,
      text = _ref.text,
      offsetX = _ref.offsetX,
      offsetY = _ref.offsetY,
      alignX = _ref.alignX,
      alignY = _ref.alignY,
      cornerOffset = _ref.cornerOffset,
      mode = _ref.mode,
      target = _ref.target,
      onClose = _ref.onClose;

  var _useState = useState({
    x: 0,
    y: 0
  }),
      _useState2 = _slicedToArray(_useState, 2),
      pos = _useState2[0],
      setPos = _useState2[1];

  var containerRef = useRef();

  var _useDOM = useDOM(),
      document = _useDOM.document;
  /* eslint-disable no-restricted-properties */


  var fixedPortal = useMemo(function () {
    return target.closest("[".concat(tooltipContainerAttr, "=fixed]")) != null;
  }, [target]);
  var portalTarget = useMemo(function () {
    return target.closest("[".concat(tooltipContainerAttr, "]"));
  }, [target]);
  /* eslint-enable no-restricted-properties */

  if (IS_DEV && !portalTarget) {
    throw new Error('Use TooltipContainer for Tooltip outside Panel (see docs)');
  }

  useGlobalEventListener(document, 'click', onClose);
  useIsomorphicLayoutEffect(function () {
    var container = containerRef.current;
    var targetBounds = target.getBoundingClientRect();
    var portalBounds = portalTarget.getBoundingClientRect();
    var coords = {
      width: targetBounds.width,
      height: targetBounds.height,
      x: targetBounds.left - portalBounds.left,
      y: targetBounds.top - portalBounds.top
    };
    setPos({
      x: coords.x + offsetX + (alignX === 'right' ? coords.width - container.offsetWidth : 0),
      y: coords.y + (alignY === 'top' ? -container.offsetHeight - offsetY : coords.height + offsetY)
    });
  }, [target, portalTarget]);
  return /*#__PURE__*/ReactDOM.createPortal(createScopedElement("div", {
    vkuiClass: classNames(baseClassName, "Tooltip--x-".concat(alignX), "Tooltip--y-".concat(alignY), "Tooltip--".concat(mode), {
      'Tooltip--fixed': fixedPortal
    })
  }, createScopedElement("div", {
    vkuiClass: "Tooltip__container",
    style: {
      top: pos.y,
      left: pos.x
    },
    ref: containerRef
  }, createScopedElement("div", {
    vkuiClass: "Tooltip__corner",
    style: _defineProperty({}, alignX, 20 + cornerOffset)
  }), createScopedElement("div", {
    vkuiClass: "Tooltip__content"
  }, header && createScopedElement(Subhead, {
    weight: "semibold",
    vkuiClass: "Tooltip__title"
  }, header), text && createScopedElement(Subhead, {
    weight: "regular",
    vkuiClass: "Tooltip__text"
  }, text)))), portalTarget);
};

var Tooltip = function Tooltip(_ref3) {
  var _ref3$children = _ref3.children,
      children = _ref3$children === void 0 ? null : _ref3$children,
      isShown = _ref3.isShown,
      portalProps = _objectWithoutProperties(_ref3, ["children", "isShown"]);

  var _useState3 = useState(),
      _useState4 = _slicedToArray(_useState3, 2),
      target = _useState4[0],
      setTarget = _useState4[1];

  if (IS_DEV) {
    var multiChildren = Children.count(children) > 1; // Empty children is a noop

    var primitiveChild = hasReactNode(children) && _typeof(children) !== 'object';
    (multiChildren || primitiveChild) && warn(['children must be a single React element, got', multiChildren && 'multiple', primitiveChild && JSON.stringify(children)].filter(Boolean).join(' '));
  }

  var childRef = /*#__PURE__*/isValidElement(children) && (isDOMTypeElement(children) ? children.ref : children.props.getRootRef);
  var patchedRef = useExternRef(setTarget, childRef);
  var child = /*#__PURE__*/isValidElement(children) ? /*#__PURE__*/cloneElement(children, _defineProperty({}, isDOMTypeElement(children) ? 'ref' : 'getRootRef', patchedRef)) : children;
  return createScopedElement(Fragment, null, child, isShown && target != null && createScopedElement(TooltipPortal, _extends({}, portalProps, {
    target: target
  })));
};

Tooltip.defaultProps = {
  offsetX: 0,
  offsetY: 15,
  alignX: 'left',
  alignY: 'bottom',
  cornerOffset: 0,
  isShown: true,
  mode: 'accent'
};
export default Tooltip;
//# sourceMappingURL=Tooltip.js.map